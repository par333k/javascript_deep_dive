```javascript
const foo = () => {};
const bar = () => {};

foo();
bar();
```
위 예제의 foo 함수와 bar 함수는 호출된 순서대로 스택 자료구조인 실행 컨텍스트 스택에 푸시되어 실행된다.
함수가 실행되려면  "함수 코드 평가 과정"에서 생성된 함수 실행 컨택스트가 실행 컨택스트 스택에 푸시되어야 한다.
즉, 함수가 호출된 순서대로 실행되는 이유는 호출 순서대로 실행 컨택스트 스택에 푸시되기 때문이다. 이처럼 함수의
실행 순서는 실행 컨텍스트 스택으로 관리한다.

> 자바스크립트 엔진은 단 하나의 실행 컨덱스트 스택을 갖는다.   

이는 함수를 실행할 수 있는 창구가 단 하나이며, 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미한다.
실행컨택스트 스택의 최상위 요소인 실행중인 실행 컨택스트를 제외하면 나머지는 모두 대기중인 테스크이다.
현재 실행중인 함수가 종료되면 비로소 실행되기 시작한다.

이처럼 자바스크립트 엔진은 한 번에 하나의 테스크만 실행할 수 있는 싱글 스레드 방식으로 동작한다.
싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우
블로킹이 발생한다. setTimeout 함수나 sleep함수로 확인해보자.

```javascript
// sleep 함수는 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출한다.
function sleep(func, delay) {
  // Date.now()는 현재 시간을 숫자(ms)로 반환한다.("30.2.1. Date.now" 참고)
  const delayUntil = Date.now() + delay;

  // 현재 시간(Date.now())에 delay를 더한 delayUntil이 현재 시간보다 작으면 계속 반복한다.
  while (Date.now() < delayUntil);
  // 일정 시간(delay)이 경과한 이후에 콜백 함수(func)를 호출한다.
  func();
}

function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

// sleep 함수는 3초 이상 실행된다..
sleep(foo, 3 * 1000);
// bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 블로킹된다.
bar();
// (3초 경과 후) foo 호출 -> bar 호출
```
위 예제처럼 작업할 경우, bar 함수는 3초 뒤 foo가 호출되고 나서 호출된다.
이처럼 실행 테스크가 종료할 때까지 다음 실행 테스크를 대기하는 방식이 동기 처리이다.
동기 처리는 실행순서를 보장하는 장점이 있지만, 앞선 태스크가 종료되지 않으면 이후 테스크가 블로킹되는 단점이 있다.

타이머 함수인 setTimeout을 사용하여 수정하면 비동기 방식으로 같은 작업을 처리할 수 있다
```javascript
function foo() {
  console.log('foo');
}

function bar() {
  console.log('bar');
}

// 타이머 함수 setTimeout은 일정 시간이 경과한 이후에 콜백 함수 foo를 호출한다.
// 타이머 함수 setTimeout은 bar 함수를 블로킹하지 않는다.
setTimeout(foo, 3 * 1000);
bar();
// bar 호출 -> (3초 경과 후) foo 호출
```
이처럼 현재 실행중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 것이 비동기 방식이다.
비동기 처리 방식은 블로킹이 발생하지 않는다는 장점이 있지만, 태스크의 실행순서를 보장하지는 않는다.
타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.
비동기 처리는 이벤트 루프와 태스크 큐와 깊은관계가 있다.

